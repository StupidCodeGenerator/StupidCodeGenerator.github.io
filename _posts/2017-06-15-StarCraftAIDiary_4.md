---
title: "星际争霸AI日记_4"
layout: post
description: ""
robots: none
---

09:33

干脆搞一个生产计划表。因为一开始用两个数值表示了当前正在制造的农民以及希望的同时造农民的最大值。

但是后来发现造房子也是，需要明确造几个。否则一旦缺少房子，Ai就会把所有的虫卵变成房子。于是我们又得限定需要几个房子。

所以设计一个计划表。比如需要同时造多少农民，同时造多少房子，这样。

索引有两种方式。因为本身UnitType就是int值，可以直接作为index使用。也可以写个转换表，这样可以避免创建一个巨大的数组。

另外，外面需要调用的函数可以写到头文件里面，但是如果只是自己用，完全可以只把定义写到cpp里面。这就相当于private了。

12:20

Training 相关表

NumOfUnitsTraining 以及 MaxOfUnitsTraining

如果要造某东西，并不是直接查找虫子然后孵化，而是更新这个表。

然后在Update里面会不断检查这个表，如果发现某东西生产不足，就会启动孵化。

如果 NumOfUnitysTraining < MaxOfUnitsTraining 就不启动孵化。

这样，如果你需要停止建造某物，需要修改它的Max值。

另外，需要一个把UnitType转换成Index的函数，以及一个把Index转换成Type的函数

12:43

可以写一个PlanToTrain的函数，用来给定Type，需求，然后修改Max数值。

Max是手动修改的，Num不是手动修改的

12:51

不对

刚才那个系统，特别适合农民，但是不适合其他兵种。

TrainingPlan应该是个递减的量。造完就结束。

对于持续造农民的那种，一个一个造，就应该写逻辑，当一个农民造出来以后，再造。这个逻辑很特殊，和其他的建造都不同。

我应该是过于关注农民的建造，影响了其他逻辑的设定。

补农民是一个特殊逻辑。

13:55

造农民的好使了，但是造房子还是继续造，不知道为啥。这个和我设计的有区别啊。

如果MOrph函数有问题，可以考虑遍历所有的蛋。另外为啥造了一个房子，Plan没有减少？

21:00

造房子不减少的原因找到了，计划里面我做了判定，只能增加不能减少。

但是实际上这个结构还是不合理。应该是一个自减的计划表。说白了，比如我要造一个农民，我就在计划里面+1.
当这个农民开始造了，这个计划就-1. 然后他就归零了，就没有计划了，农民就不造了

这种情况下，需要上一层的逻辑来控制持续造农民或者持续造房子。

这个计划表的功能已经缩小到，避免在Update中持续的制造某种东西。

21:43

不行啊，还是得需要一个InProgress的判定。看来还是得麻烦。但是Plan确实需要递减，从Plan移动到Progress

21:55

AI 有Speech功能，可以作为DebugLog使用。用来跟踪事件。

22:20

现在是，如果在Progress内，则对Plan的设置不会增加Plan

23:19

去他第，不要在这个订单系统上浪费时间了。订单就是追加，没有什么特殊的逻辑。

如果在Update里面重复下单，就是一直建造。就这样

Progress还是留着，用作判定。

23:25

这玩意就是订单系统，按照订单来的就没问题。

不要让函数做过多的工作，将来阅读代码的时候就坑了。

另外，多从现实中的系统获取经验。邮递啊，网店啊，都有可以借鉴的东西。

0:20

在第一个房子出来的一瞬间，人口还没有被加上，但是这个时候造房子已经完工。所以造完一个房子的瞬间又造了一个房子。

这个比较坑啊。

但是我绝对不改函数内逻辑了，这个通过增加判定条件来算。