---
title: "星际争霸AI日记_全部"
layout: post
description: ""
robots: none
---

每次开发都得新建文件，太麻烦。所以全写在一个文件里算了。

--- 2017-06-12 ---

今天晚上打算搞一版。第一版的计划是单纯的虫族暴兵平推，看看能不能推死星际原版AI以及公司同事。毕竟第一版，简单为主。微操什么的统统的没有，就是暴兵然后推。

目前决定分成三个主要的Manager：

TopManager：最高决策层，用来下达粗略的指令。比如发展经济，侦察，进攻等等。

SupplyManager: 后勤决策层，用来组织农民，发展经济，造人口。

AttackManager：前线决策层，用来进行战术侦察，进攻。

简单的说，TopManager首先对SupplyManager下达发展资源的指令，当资源人口到达一定指标后，下达指令造血池。在此期间，派一个房子探近点，一个农民探两个远点。当狗攒到一定程度以后，下达指令给AttackManager，AttackManager召集所有的小狗，开始平推。

今天的计划：

SupplyManager 造房子（虫族的房子不太一样），造血池。


21:10

当前的代码已经包含了虫族建造房子的特殊逻辑。所以下一步就是在人口为7的时候，停止造农民，并且造血池。

那么，如何停止造农民？

首先，找到造农民的代码。然后定义一个flag，表示农民制造state。目前定义FULL表示全力造农民，STOP表示停止造农民

在此之前，先定义一个SupplyManager，并且将逻辑全部移动到SupplyManager里面


21:42

我把建造的代码移动到了SupplyManager文件里面。并且我没有创建类，使用的是纯C代码。我可以尝试一下使用纯C代码能不能构建一个可以用的AI。C++的特性太多，我怕有太多坑。如果C++的面向对象足够优秀，也就不会有后来的Java了。

22:29

BWAPI 使用了一个叫SetContainer的类。而这个类本质上来自于unordered_set类。

unordered_set 本质上是啥？

另外 C++的 reference 和 C的 指针到底有啥区别？这些都是需要研究的问题。也是增加技能的点。
毕竟没有深入研究过C++，对C++的很多坑还是搞不清楚。我一般倾向于用指针的，因为简单啊。

--- 2017-06-13 ---

12:21 

今天计划是首先把血池造出来。7人口停农民，等到200金钱造血池

1. 关于如何获得人口上限

GameWrapper可以获得self（pLayer类型），然后里面有supplyTotal 数据， int类型，表示当前人口上限。
supplyUsed表示当前已经使用的人口

12:35

写完7个人口停农民。可以试试

12:55

停农民成功，下一步进行200人口造血池。

13:05

200金钱的时候，所有农民全去造狗池了！卧槽！

如果将来AI复杂了，需要一个“任务表”。表示当前农民正在进行的工作。这样农民不会去做重复的工作.

13：15

农民已经可以选择一个去造血池了，但是是抱着矿去的。需要增加一个判定条件。

另外，血池放下以后，需要继续等待。等到血池造好，要造三条狗。

三条狗造完，重新开始造农民。

需要研究一下这个过程中，农民和狗的比例。初步定1比1的造。一条农民一条狗。

等到350钱，造分矿。

看样子，即使是一个小AI，也需要一个TopManager了。另外SupplyManager需要一个任务表，知道目前总体上正在做的工作。每一条任务应该是一个结构体，拥有一个任务类型，优先级，数量，等等。

21:02

AI 造出了最初的三只狗。但是却停止了造房子，并且没有开分矿。

另外，游戏中的位置是如何算的？

都能获取到哪些位置？

21:18

StatusTable 状态表，最简单的实现方式是一个结构体，包含若干布尔值，数值等。比如当前是否在建造房子，是否正在开分矿，是否需要造农民，是否爆兵，每一种建筑都造了几个，等等。

TaskList， 任务列表，一个链表。每一个元素应该是一个结构体，里面包含任务类型等数据。

21:59

没必要搞链表，用一个指针数组就可以，然后有一个MAX_TASKS来表示最多可以放入多少任务，SUPPLY_TASK_EMPTY 用来表示空任务。但是这个指针数组还是用NULL来表示当前位置为空没有任务。当加入新任务的时候，遍历这个数组来寻找空位插入。

一般来说，任务下达不会非常频繁，所以不用考虑效率问题。

22:38

乱了，乱了

先从架构开始搭，首先是 全功能的 SupplyManager。包含一个由数组构成的Tasks数组，一个由一堆布尔值和其他类型变量组成的，松散的Status集。

Tasks配套有 AddTask，RemoveTask函数。（先实现AddTask）

Status 就手动配置就好了。

Tasks 里面的任务，会在Update中被处理。如果Task满足条件，就会被执行然后被消除

说白了， Tasks里面包含的是未完成的任务

其实如果任务足够简单，可以用一组布尔值来判定。但是为了将来扩展方便，还是简单的用数组记一下。

Tasks 需要跟一个Has函数，否则会不断的增加Task

我是否应该用一组布尔值表示任务？

不行。将来加入侦查任务等，会有其他的参数。布尔值仅仅能表示一些基本的任务，比如人口不足

如何避免同样的Task被重复插入？换言之，需要研究一下结构体的HashCode算法，或者是自己写一个逻辑，总而言之，拥有同样内容的Task不可以被重复插入。

--- 2017-06-14 ---

21:05

如何避免重复的Task输入？如何保证Task唯一性？手动判定？

目前短期的问题，Task 如果做ID处理， 也不能解决问题， 因为每次也是生成新的Task。
只能从TaskType上着手。

目前来说， 对于造房子的任务， 就先用TaskType做判定把。

21:32

整理一下造房子的流程。

是不是应该有Larvar始终Update的函数？在不需要造东西的时候，是不是不需要便利Larvar

农民也是一个个的造

找到一个Larvar造就可以了

Supply应该有一个Train函数。给定UnitTYpe就可以训练某一兵种。

22:07

设计一个 NumOfWorkersTraining 的属性，统计当前同时有多少个农民正在被创建。

在一般情况下，农民都是一个跟着一个的创建。

在农民缺乏的时候，上层可以给Supply层下达指令增加产量。

NumOfWorkersTraining 在开始创建任何一个农民时，+1. 在UnitCreate事件发生，Type为农民的时候，
这个数值减一。可以在屏幕上输出以观察。

另外， OnStart的时候，需要归零。

22:31

SUPPLY_TASK_MORE_WORKERS 指令被细化成 SUPPLY_TASK_ONE_WORKERS_A_TIME. 表示农民一个一个的造。
将来还会有多个一起造的指令

22:34

TASK 模型只是用来上层和下层进行通信。Supply里面还是需要一组状态来约束很多行为。比如不但要知道 NumOfWorkersTraining,
还需要知道 MaxOfWorkersTraining. 前一种是状态，后一种是约束。

回头看看吧，要是写着写着Task的作用不明显了也许就砍掉了，留着一个没用的系统绝壁是后患。

我决定复制一个版本，然后去掉Task这个看起来很坑的功能。

如果他让代码变得复杂，而不是简单，就没有这个必要。因为和人不一样，程序完成所有任务都是瞬间完成的。

至少在SupplyManager里面，这个东西没啥用。

人的操作也是，只有非常少数的工作，需要被记录下来并且延迟完成。

但是 SupplyManager 还是绝壁有用的。如果所有的东西都写在一个模块里，肯定炸了。

到时候连上帝都拿这代码没招。

23:06 

我再整理一下。MaxOfWorkersTraining 表示最大可以接受的同时制造农民的数量。 NumOfWorkersTraining 表示当前同时制造的农民数量。
MaxOfWorkersTraining 需要手动设置，而NumOfWorkersTraining 在开始制造一个农民时增加，在一个农民产生时减少。这个需要输出看一下。

去掉Task以后，功能陷入瘫痪，先解决造农民的问题再说

23:16

由于Supply在星际里面有特指，表示人口上限。所以原来的SupplyManager被改成ResourceManager，并且所有的前缀都改了

23:42

刚才在编译的时候，遇到了 Internal Error. 我后来把Release目录下的已有文件全部删除再编译就过了。可能是因为有进程占用了这个文件？

23:55

虫族比较奇怪，OnUnitCreate和OnUnitMorph是两个事件。Morph表示一个单位被创建了。也许虫族只有小虫子是被创建的？

注释里面说，是因为暴雪这么干，我才这么干。

另外，需要创建TopManager了。里面应该有一个叫做Flow的东西。一大坨逻辑，写明了一场比赛在什么时候做什么事。

--- 2017-06-15 ---

09:33

干脆搞一个生产计划表。因为一开始用两个数值表示了当前正在制造的农民以及希望的同时造农民的最大值。

但是后来发现造房子也是，需要明确造几个。否则一旦缺少房子，Ai就会把所有的虫卵变成房子。于是我们又得限定需要几个房子。

所以设计一个计划表。比如需要同时造多少农民，同时造多少房子，这样。

索引有两种方式。因为本身UnitType就是int值，可以直接作为index使用。也可以写个转换表，这样可以避免创建一个巨大的数组。

另外，外面需要调用的函数可以写到头文件里面，但是如果只是自己用，完全可以只把定义写到cpp里面。这就相当于private了。

12:20

Training 相关表

NumOfUnitsTraining 以及 MaxOfUnitsTraining

如果要造某东西，并不是直接查找虫子然后孵化，而是更新这个表。

然后在Update里面会不断检查这个表，如果发现某东西生产不足，就会启动孵化。

如果 NumOfUnitysTraining < MaxOfUnitsTraining 就不启动孵化。

这样，如果你需要停止建造某物，需要修改它的Max值。

另外，需要一个把UnitType转换成Index的函数，以及一个把Index转换成Type的函数

12:43

可以写一个PlanToTrain的函数，用来给定Type，需求，然后修改Max数值。

Max是手动修改的，Num不是手动修改的

12:51

不对

刚才那个系统，特别适合农民，但是不适合其他兵种。

TrainingPlan应该是个递减的量。造完就结束。

对于持续造农民的那种，一个一个造，就应该写逻辑，当一个农民造出来以后，再造。这个逻辑很特殊，和其他的建造都不同。

我应该是过于关注农民的建造，影响了其他逻辑的设定。

补农民是一个特殊逻辑。

13:55

造农民的好使了，但是造房子还是继续造，不知道为啥。这个和我设计的有区别啊。

如果MOrph函数有问题，可以考虑遍历所有的蛋。另外为啥造了一个房子，Plan没有减少？

21:00

造房子不减少的原因找到了，计划里面我做了判定，只能增加不能减少。

但是实际上这个结构还是不合理。应该是一个自减的计划表。说白了，比如我要造一个农民，我就在计划里面+1.
当这个农民开始造了，这个计划就-1. 然后他就归零了，就没有计划了，农民就不造了

这种情况下，需要上一层的逻辑来控制持续造农民或者持续造房子。

这个计划表的功能已经缩小到，避免在Update中持续的制造某种东西。

21:43

不行啊，还是得需要一个InProgress的判定。看来还是得麻烦。但是Plan确实需要递减，从Plan移动到Progress

21:55

AI 有Speech功能，可以作为DebugLog使用。用来跟踪事件。

22:20

现在是，如果在Progress内，则对Plan的设置不会增加Plan

23:19

去他第，不要在这个订单系统上浪费时间了。订单就是追加，没有什么特殊的逻辑。

如果在Update里面重复下单，就是一直建造。就这样

Progress还是留着，用作判定。

23:25

这玩意就是订单系统，按照订单来的就没问题。

不要让函数做过多的工作，将来阅读代码的时候就坑了。

另外，多从现实中的系统获取经验。邮递啊，网店啊，都有可以借鉴的东西。

0:20

在第一个房子出来的一瞬间，人口还没有被加上，但是这个时候造房子已经完工。所以造完一个房子的瞬间又造了一个房子。

这个比较坑啊。

但是我绝对不改函数内逻辑了，这个通过增加判定条件来算。

--- 2017-06-16 ---

12:19

调试一下，开始造血池。

在造血池之前，先构建TopManager，里面有FlowUpdate，作为流程控制。然后FlowUpdate中，满足条件造血池。

另外，造农民，停农民，也是TopManager。

12:37

房子造完的一瞬间，人口上限还没有涨上去，但是当时房子已经造出来了。所以它会紧接着造第二个房子。

目前我想到的解决方案是，不去看当前的TotalSupply，而是对房子进行计数。

目前看来，星际里面所有的Supply来源都是房子。

13:09

重新写了停农民的代码。另外，“持续造农民”,"全力造农民"之类的逻辑，应该在ResourceManager里面抽取成函数。

--- 2017-06-18 ---

12：02

做到今天，有点累呢。才完成开局的六只狗。

首先要做的是，研究位置系统，然后尝试获取到矿点位置并且一开局的时候让房子侦查近点。从今天开始要打LostTemple地图。可以把所有的地图都删了，只剩LostTemple。

然后查找BWAPI，尝试控制房子移动。

13:06

BWAPI::Game::getStartLocations ()

这个函数给出了一个序列，可以进行遍历。尝试在开头输出这些点，以及自己的StartLocation

14:33

很好，现在一开始房子已经回去自动找近点进行侦查了。下一步是，房子如果侦查到了近点有敌人，则立刻返回，并且记录下敌人的位置。
如果房子抵达近点但是没有侦查到敌人，则在放下血池以后派一个农民侦查第二近点。

目前为了简单，AI只打四人图，两人局。

这个工作要交给AttackManager去做。现在还是放在TopManager里面了。TopManager负责流程控制和中央调度。

改出来。

16:29

Unit 本身就是 UnitInterface*. 这个我觉得不好。第一是，指针要明显的表示出来是指针。第二，typedef我觉得真是少用为妙，
尤其不要带有类型上的改变

21：21

侦查逻辑有问题，本来写的房子发现敌人回来，这下可好立刻就回来了。看来是对战争迷雾的判定有问题。

--- 2017-06-19 ---

21:56

目前AI已经学会在一开始的时候放出房子进行侦查，并且血池造下以后也会派一个农民出发。但是这个农民走向了近点。我应该在逻辑一开始的时候就设计好第一侦查位置和第二侦查位置。

22:44

诶卧槽为啥农民总要去近点？

哦，可能是当init结束以后，被释放了

说的通。这样一来，当农民外出侦查时，还是优先找近点，因为定好的近点被释放了。

22:56

如果当前发现了敌人，那么设置一个敌人的点 enemyPoint。如果这个点不为空，则所有的搜索取消，侦察兵回家。

23:22

c++ does not support default-int

如果TilePosition定义了 extern声明，则会报这个错误。我不知道为什么。

先不写了，感觉和Typedef有一定关系。

--- 2017-06-20 ---

12:23

如何解决 TilePosition 不能声明到外部的问题？尝试使用Position进行定义呢？

做个实验，定义一个Position，写在头文件里

12:37

并不是所有的class放到头文件里面都会有问题。所以这个应该是TilePosition实现的问题。所以看来应该把这些Manager放到一个class里面好一些。

19:02

我现在要把原有的逻辑放到class里面了。这是个大工程。

22:26

我把代码改成C++的形式了，用类进行封装。

另外，类里面声明的 static 变量，需要在cpp 文件里面定义。关于定义和声明，我应该仔细的研究一下。

另外，改成了C++形式以后，函数的前缀可以拿掉了。

23:14

TilePosition 和 Position不能混用。在比对地图位置的时候要使用 UnitInterface.GetTilePosition()

BUG, 在3点钟方位开始时，第二第三侦查点都没有.

23:55

把近点的寻找和23点的寻找分开就对了。对啊，第一点都没找到，如何确定二三点啊，这个逻辑就有问题。

--- 2017-06-22 ---

12:29

现在前期侦查已经OK。

六只狗摆下以后，应该立刻造一个房子，补农民。

侦查到敌方单位以后要确定敌方种族。

获得敌人方位以后，六只狗出发。要躲地堡，优先攻击机枪兵，狗，以及神族的狂热者。

其次，攻击敌人的农民。

问题：

1. 如何躲地堡？

需要获得地堡的位置，并且计算安全距离，并且要控制自己的小狗远离敌人的地堡。

2. 如何规划路径？自己做路径规划？

需要继承一个Unit类么？不过确实，UnitInterface本身就是一个Interface，只提供了最基本的接口。
并不能赋予更复杂的寻路算法。所以可以

PS. 当前的后勤管理器，Plan系统可以用C++的list, 双向链表。优先级高的可以从前面插入，优先级不高的可以尾部放入。

22:20

头文件中声明的类中的静态变量需要在cpp中重新定义，而非静态的不用。

如果Wrapper 里面的unit被释放了怎么办？

必须在 OnUnitDestory 里面，编写逻辑实现Unit被释放以后，UnitWrapper也被释放。

--- 2017-06-23 ---

12:56

UnitWrapper 里面也是一次执行一个指令，没有并行指令

今天事儿比较多，没有倒出空写

--- 2017-06-24 ---

14:36

API 中大量使用了std::list，所以我也可以使用list，虽然我听说过很多关于C++库有各种问题的说法，但是既然API里面用，我也就用。什么时候当我把C/C++游刃有余的使用时，我再决定自己的技术风格。

回头，把plan系统，和UnitWrapper应该有的orderlist系统，统统研究透。

另外，除了UnitWrapper之外，还有另一种思路，就是直接把UnitWrapper结构，设计成一个Manager控制很多个Unit那种。然后遍历它们依次下达指令。但是这样代码会比较混乱。

20:59

我觉得我可能有点过度设计了。先解决进攻问题吧。把UnitWrapper先留着

21:59

六只狗造完以后，等待一下。因为目前的第一波骚扰，对于当前版本AI非常坑比的操作来说，非常之没用。

如此一来，需要6d造狗么？9d是不是更科学？

22:28

目前看来，开分矿的矿点，API并没有提供，需要自己根据矿的位置来算放置分矿的位置了。

首先要明确，从什么地方可以get到类型为MineralField的Unit。

然后对MineralField 进行分析，分辨矿的走向，以及紧挨在一起的矿的个数。

然后计算矿的那一边是平地。 也有两边都是平地的。

然后计算矿朝向那一边弯曲。

以上这些都是可以抽象出来的模块。

然后，计算这一簇矿区的最佳建造位置。通过调试信息在屏幕上显示出来。

22:41

现有的代码太乱了，我需要整理一下思路，重写这坨代码。

现在的问题：

1. AI需要随时明白，自己处于什么样一个状态，应该做什么样的事儿。

2. AI需要有一个非常健壮的，非常堪用的计划系统。目前看来最大的问题出现在这里。

3. AI需要一套宏观指令，用来进行高效的决策传达。

所以，本质上，AI的大框架肯定是状态机，算法什么的都是往里面填充的内容。这个状态机设计的合理性，决定了整个AI的健壮性。

AI不需要三个管理器，只需要前方和后方两个管理器即可。后方负责爆兵，扩张等等，前方负责进攻，侦查。

作为一种设计原则，就是，只有当需要抽象的时候再抽象，任何过分的抽象都是增加复杂度的元凶。

所以：新的架构只有两个主要模块。剩下的都是辅助功能，每一种完成一个特定的操作。

--- 2017-06-25 ---

14:58

AI 的流程控制 FlowManager

所谓流程，应该是一个顺序递进的，庞大的状态机。每一个流程节点，都有一个结束标准。

一个流程结束，自动开启下一流程。

16:02 

就叫StateManager，简单明了。现在就三个模块了，Front，Back，State

StateManager不做实际操作，它只负责记录状态以及状态间的转换。

State的修改写成private，外面没有权限修改State，只有权限获得State. 这样可以保证外面很干净

然后，当StateManager的State发生变化，通过直接调用的方式告知其他的Manager

16:22

原来架构里面，比较好用的计划系统。但是需要修改成List方式的，或者队列状态的也对。

优先尝试使用std::queue，并且定义计划对象。当前的计划系统，被简单的定义为：Unit计划系统。
它负责在条件满足的时候，创建Unit。它可以被简单的定义为一个UnitType队列。可以封装一个函数，
当需要增加多个计划的时候，可以循环插入。

建造中的Unit，遍历Unit获得。在每一帧的开始，缓存必要的信息，尽可能的保证只有一次Unit遍历。
可以在屏幕上在每一帧的开始，遍历Unit然后输出到屏幕上。这个工作，交给BackManager进行。

20:20

UnitType里面的Beacon表示灯塔，没啥用，一般用作剧情模式的任务点。对抗里面看不见

20:30

Plan 系统看来需要抽象出来，做个结构体。因为还需要表示位置信息，尽管对于可移动的Unit，位置信息并不重要，
但是对于建筑物来说，位置信息非常关键，尤其对于开分矿来说。位置信息也可以缺省，这样Plan系统会随机位置构造建筑物。
但是这个抽象层貌似逃不掉了。

21:38

为了代码更简单，多循环几次全部Unit不重要。并且作为一个AI，将来肯定还有慢得多的代码在后面等着。所以PlanUpdate里面就直接循环了

21:55

如何判定当前正在建造的建筑物？因为告诉农民build了以后，这个时候金钱还是会被消耗，并且会有兵走过去。这个时候有可能造成本来决定建造了，但是到地方没有造出来。这个尴尬的问题如何处理？

最简单的方案是，在有农民去建造建筑物的时候，停止计划中的活动，等待建筑物建造完成。这样可以避免由于资源问题导致的建造失败。同时，如果因为其他单位占用了建造的位置，尝试换一个位置进行建造。这种方案需要解决一个问题，就是农民造建筑物发生障碍的回调是什么

22:33

现在还没解决建筑物建造被打断的问题。这个事儿以后再研究。

--- 2017-06-26 ---

12:39

我把当前的Plan里面的queue对象做成public。去他妈的把，方便最重要

12:49

当前工作重点，状态表设计。

12:56

注释中的Supply数值统一使用乘2表示。这样可以和代码保持一致

13:11

经过测试，新的计划系统已经运作。

21:31

状态机已经实现，现在要实现第一个状态到第二个状态的切换，并且在屏幕上显示出当前的状态号 

22:14

第二个状态已经写完，测试。第二状态一直作用到第二个房子的人口用完。

前期几乎不会遭遇攻击，所以好办一些.

22:17

当开始造血池的时候，队列忽然被清空了。。。少了一个Break

22:22

妈个鸡，被虫族的快攻干了。这个AI目前只针对TVP啊哈哈，别的先不管.

最后增加一个基地，先造在主矿区里面把，干一波单矿四基地。并且在第二状态开始的时候派出侦查

22:28

关于侦查等进攻性行为，可能也需要一个数据结构来简化。两种思路：

1. Unit的包装类。

2. 一个松散的，放在BackManager里面的，工作队列。

目前看来，Unit包装类更靠谱一些。在每一帧的开始，遍历自己的全部Unit，然后一个个的封装到Wrapper里面。

这样的好处是可以避免频繁的Hash。

农民采矿是一个独立的逻辑，不发生关系。但是优先执行包装类里面的计划。

可以考虑把计划显示到头顶上。

22:54

明日TODO：UnitPlan

--- 2017-06-28 ---

12:22

用一中午的时间，实现UnitWrapper以及Plan

UnitWrapper 在每一帧的Update中会验证 unit 是否还存在，如果不存在，则析构。

Unit 里面的plan，叫做ActionPlan

--- 2017-07-02 ---

10:32

我已经找到了如何shift指令的方法。但是由于后期可能存在的复杂指令，比如绕着地炮跑之类的，以及攻击的优先级等等，还是需要一个Unit包装类，用来实现将来可以在Unit身上实现的复杂算法。

10:49

实现UnitWrapper以后，把UnitWrapper挂到MyAiModule里面

11:07

看一下范例代码里面怎么实现的在屏幕上显示文字

16:18

好像又弄得复杂了。UnitWrapper先删掉吧。FrontManager解决一切

16:27

恩，唔了。UnitPlan应该和TrainingPlan（BuildingPlan）是类似的。不对Unit进行包装，一样可以实现Unit的计划任务系统。和BuildPlan一样, 只是把Unit的指针传入即可

19:45

操他妈，因为面向单位的操作都是实时的，所以没必要计划。我今天的状态真的不好。

20:44

去掉了计划以后，把以前写的侦查方法放到现在的代码里面. 

20:59

貌似应该前端和后端是两个状态机？后端通过现在造了多少兵，造到什么程度上进行区分。而前端通过现在正在进行侦查，还是进行第几波攻击来区分。两个状态机可能会相互等。

现在先不这么做，如果需要这么做自然而然代码会往那个方向发展。

21:42

在使用move指令的时候，第一个move不能使用带有shift参数的move

21:50

让虫族第二状态完成造20个狗。然后检查是否造完全部的狗并且已经查到对手的位置，发起攻击。

22:35

UnitMorph可以告诉我们现在是否已经有建筑物落下，落下的是什么。那么我们就可以知道，刚才放下的建筑物是否已经造好。但是还是最好能够拿到建造失败的事件。我要翻翻API的源代码。

或者换一种思路，一旦一个农民被作为builder，那么它最后肯定会死。那么我们检测这些builder，如果他们没死，并且没有isConstructing，那么就证明build失败了。我们需要重新build

建造检查还是有BUG,先不管了

--- 2017-07-03 ---

13:32

中午和安老师进行了一下演练，毫无悬念的惨败，但是总结了一些经验教训。

1. AI会被对方的兵牵着鼻子走。如果我让AI往对方的家里去，又会导致AI被堵死在路口。这样，必须研究一个详细的逻辑来决定AI是否应该攻击对方的老巢还是遇到的杂兵。

2. AI的建筑过程确实会无故断掉。

3. AI前期过于薄弱，并且现在AI不懂得如何防守。

20:42

我修改了一下进攻策略。如果有路径干对方老家就干。如果没有就干杂兵。

另外可以如果自己挨干了就反击敌人的杂兵。如果一段时间内，比如100帧内没有挨干，就继续干老家。

另外赶紧把探道采矿那个傻逼搞回来。

--- 2017-07-04 ---

12:57

当前的AI需要一套可靠，稳定的当前状态识别系统。当前在造什么东西，都有什么东西，等等。

14:39

绝对不能直接调用建造或者Train，因为时间差的问题只能通过延时解决。所以用计划系统可以一劳永逸解决问题。
但是计划系统不能用queue了， 应该用普通的list，这样可以 push_front ，提高优先级。
如果需要当前立即建造什么东西，可以 push_front 这样就会立即执行，并且可以保证执行一次。

但是Process依然需要，有空写一个Process系统，和计划系统链接。这样通过完全避免直接建造，达到可靠建造的目的。

PS：

今天第一次灭掉了星际官方AI，截图留念。但是我发现现在的打法很难打掉人族。

![img](https://raw.githubusercontent.com/StupidCodeGenerator/StupidCodeGenerator.github.io/master/images/FirstBeat.jpg)

--- 2017-07-06 ---

10:38

后来我想了一下，侦查者有必要抽出一个单独的模块出来，原因是因为这个模块有一套单独的状态列表，会和现有状态冲突。

另外，关于敌人的位置等信息也可以抽象到这里，说白了现在已经和真实军队的基本结构差不多。后勤部门，前线部门，情报部门。

20:12

正式定义InformationManager, 情报管理器

--- 2017-07-06 ---

10:38

后来我想了一下，侦查者有必要抽出一个单独的模块出来，原因是因为这个模块有一套单独的状态列表，会和现有状态冲突。

另外，关于敌人的位置等信息也可以抽象到这里，说白了现在已经和真实军队的基本结构差不多。后勤部门，前线部门，情报部门。

20:12

正式定义InformationManager, 情报管理器

--- 2017-07-23 ---

PS：连着加了半个月的班，现在终于要差不多了。

16:18

矿的聚类问题。网上的算法多用于处理比较复杂的聚类问题，而矿点的聚类比较简单

当然，最简单的算法就是用API里提供的getBuildLocation函数来定。

不过反正也是个长期的工程，还是一次性做到位。

首先当发现了距离出生点超过30个Tile的矿的时候，记录下这个矿。然后查看已知矿点，看看这个矿是否距离某矿点30Tile以内。

频繁的用到的这个30Tile（900pix）的长度，可以作为“矿区半径”进行抽象。

如果没有找到，证明这是一个新的矿点，将其位置加入到矿点列表。

如果找到了，证明他属于一个矿点，将其加入到所属于的矿点旗下的列表中。

目前逻辑写到这里，是将每一个矿区发现的第一个矿作为矿点的。

然后可以做一个定时器，一定时间以后，如果这个矿点没有新的矿加入，则这个矿点被确定，根据矿的分布计算最佳基地建造点。

目前看来，出现了一个矿点抽象.

另外，可以在矿点30TIle的范围内搜索Gas，如果有视为一个有gas的矿点。

ResourcePointFinder应该被视为ResourcePoint才对

--- 2017-07-29 ---

11:21 

首先实现矿点的查找

在每一帧的时候，遍历所有能够看到的矿点，并且检查他们的归属地：

是否与某一矿点的距离小于30Tile？

如果大于30Tile则是一个新的矿点。

15:53

原计划的方法在侦查阶段过于繁杂，需要在每一帧不断的检查每一个点。

所以不如这样，首先收集数据，只要是看到过的矿全部记录下来（因为战争迷雾会导致获得不到自己视野外已经看到过的矿）。

当开分矿的时候，进行一次二维点聚类分析就可以了。

16:45

擦擦，原来一上来就知道所有的矿的位置。AI是读取了地图信息的。那么就可以写一个程序计算建造点，而不用考虑矿点侦查的问题了

也就是说，可以在一开始的时候，进行一次矿点计算。

首先要根据矿之间的距离进行聚合，生成矿脉。虽然地图上也会有散列的矿，但是大多数情况下矿是聚在一起的。

方法：

首先，定义一个“矿点集合”

遍历所有的矿。对每一个矿，检查它是否和某一个矿点集合里面的任意一个矿的距离小于20Tile。

否则，创建一个新的矿点集合容纳他。

这样经过一次遍历，就可以分出来.

18:07

貌似没有必要把气矿也搞一个列表存在ResroucePoint里面。因为可以在生成分矿矿点的时候，检查有无气矿

19:34

很好，现在分片的问题已经解决。下面要解决的是如何计算出最佳建造点。

有一个比较暴力的解决方法，就是针对每个矿进行10次的buildLocation计算，然后找出平均距离最近的点.

在目前我还没想到太好的其他的方法并且我需要我把项目往前推进的时候，就先这么着。

20:31

貌似在没有探路的情况下，getBuildLocation 函数会变得失去控制，并且很慢。

那么这样，简化一下。生成最佳建造点的时机不放在开始，并且只限定于农民范围内的点。

也就是说，既然已经找到了矿点，那么就在开分矿的时候派一个农民去矿点。

20:44

休息一下，构思一下矿点问题。

20:54

首先，BackManager要有一个状态用来指示现在需要开分矿, 这是一个独立的状态，停止发展并且派出农民。

以后再优化这个时间线。但是总是感觉星际的AI应该用时间线来写，并且应该是并发的。

先这么着吧。

--- 2017-07-30 ---

![img](https://raw.githubusercontent.com/StupidCodeGenerator/StupidCodeGenerator.github.io/master/images/mineposition.jpg)

12:44

矿点计算已经完成，虽然不是很完美，并且稍有卡顿，但是目前阶段够用了。

下一步要做的，是让AI进行分矿建造。本来现在就已经在不断的建造主基地，只是让他定点建造就可以了。可以使用乱矿流。即根据1个矿点15个农民的比例，分配并建造农民。并且每两个基地就开一个分矿。也就是，单矿两基地，两矿四基地，三矿6基地。

我们需要在BackManager里面记录一下自己占据了几个矿点。通过计算矿点距离内30Tile之内有无己方建筑物来判定。

20:41

首先要实现的是，既然已经知道了地图上的矿点信息，那么就需要知道自己占据了那几个矿点。

并且既然从一开始就能知道有多少矿点，那么就很明显的可以把它挪到BackManager里面了。因为根本不是侦查的事儿。

21:55

我擦，C语言的布尔值如果不初始化的话是随机值。我怎么忘了

22:03

ResourcePoint中加入与自己出生点的距离。

但是发现了一个问题，这个距离是直线距离。这个和实际路线距离有所差别啊。这咋整。。

先不管，开出分矿再说。不过以后肯定是要写一个路径长度计算的。

--- 2017-08-05 ---

现在这个AI已经可以开分矿了。下一步要解决的两个问题是：分配农民比例，以及增加寻路算法以确定实际距离最近的矿点。

重点说一下第二个，因为目前计算的是直线距离，而并不是实际的路线距离，所以AI并没有选择最佳的矿点进行开矿。

另外还有一个问题，矿点会存在建筑距离矿太近导致无法建造的问题。这个需要改进矿点算法。

引申出的一个更大的问题，就是AI本身抗干扰能力太差。

AI目前不具备宏观思维，这个比较要命。AI应该有宏观任务表才比较科学。这样如果一旦被打断立刻就能够知道自己应该干什么，并且如何调整策略以完成现有的宏观任务，抑或是放弃现有宏观任务，改变策略。

宏观系统的设计直接决定了AI可以达到的高度，而微观系统的设计

目前整个AI工作的最成功的就是这个Plan系统，它其实就是一个看起来很像宏观系统的东西。

其实我做的斗地主类的AI也有这个问题，就是它不知道当前应该做什么。

设计AI之初，首先应设计宏观系统。宏观系统设计完成后，根据宏观系统的要求来设计微观系统，为宏观系统服务。

--- 2017-08-06 ---

在设计宏观系统之前，先把农民和基地的配比设计好。当前这个AI的架构也就能支持到前期，中期都够呛，中期会变成一团乱。

所以就两基地了。这个AI本来也是第一版，第一版就没有好货。就维持在2矿，6基地，每一个基地15个农民，共30个农民

模块化设计很重要，以后可以针对模块进行升级。

另外，当前版本的矿点生成应该重新写一下，太次了。这个写好了，以后也能用上。

--- 2017-08-10 ---

当前最重要的问题是：AI开了分矿以后，战斗力没有提升，反而降低了。要考虑一下为什么。

另外，在最后疯狂爆狗的时候，Process列表会大量膨胀，好像有bug。

我首先尝试把3个狗一个农民的比例升高到5个狗一个农民。

要想最终解决建造失败的处理，就一定要有UnitWrapper或者是Unit任务表。根据UnitID来进行映射。

并且，分矿起了以后，并没有很好的进行营运。

我把开分矿的时机改到了第一波进攻开始。并且比例调成了10个狗一个农民

修改：需要增加进攻优先级，比如要优先打火力。另外，需要一个农民调度算法。

另外，如果StartLocation的敌人被干死了，要寻找所有可能的矿点。